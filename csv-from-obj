#!/bin/bash

# Given an obj file, samples it to get it as a high-quality CSV.

export readonly name=$( basename $0 )

source $( type -p comma-application-util ) || (error "comma not installed")
function errcho { (>&2 echo "$name: $1") }
function error
{
    errcho "error: $1"
    exit 1
}
# # Half-hearted attempt, never finished
# function sample() {
#   local group=$1
#   local gLines=$2
#   local lines=$3
#   local density=$4
#   local OBJ=$5
#   local id=$6
#   local verbose=$7
#
#   set=$(echo "$gLines" | grep $group -A 1 | tr '\n' ':' | sed 's/:$/\n/')
#   start=$(echo $set | cut -d: -f1)
#   label=$(echo $set | cut -d: -f2)
#   n=$(expr $lines - $start)
#
#   e=$(echo $set | cut -d: -f3)
#   if [[ $e ]]
#   then
#     end=$(expr $e - 1)
#     d=$(expr $end - $start)
#     cat verts.csv <(cat $OBJ | tail -$n | head -$d ) > $label.obj
#   else
#     cat verts.csv <(cat $OBJ | tail -$n) > $label.obj
#   fi
#   cloudcompare.CloudCompare -SILENT -NO_TIMESTAMP -C_EXPORT_FMT LAS -O $label.obj -SAMPLE_MESH DENSITY $density >/dev/null 2>/dev/null
#   cat ${label}_SAMPLED_POINTS.las | las-to-csv points | csv-shuffle -f=x,y,z -o=x,y,z | csv-paste "-" "value=$id"
#   [[ $verbose ]] && echo -n "." >&2
# }

function convert() {
  OBJ=$1
  density=$2

	cat $OBJ | grep "^v" > verts.csv

	gLines=$(cat $OBJ | grep "^g" -n | sed 's/:g//' | sed -r 's/\s/:/g')
	lines=$(cat $OBJ | wc -l)

	id=$(cat $OBJ | grep "^g" -n | wc -l)

  # export -f sample
  # echo "$gLines" | parallel -n1 -j8 sample {} $gLines $lines $density $OBJ {= '$_=total_jobs()-$job->seq()+1' =} $verbose |
	for group in `echo "$gLines"`
	do
    [[ $verbose ]] && echo "Processing $group ($id)..." >&2

		set=$(echo "$gLines" | grep $group -A 1 | tr '\n' ':' | sed 's/:$/\n/')
    [[ $verbose ]] && echo "Set: $set" >&2
		start=$(echo $set | cut -d: -f1)
		label=$(echo $set | cut -d: -f2)
		n=$(expr $lines - $start)

		e=$(echo $set | cut -d: -f4)
		if [[ $e ]]
		then
			end=$(expr $e - 1)
			d=$(expr $end - $start)
			cat verts.csv <(cat $OBJ | tail -$n | head -$d ) > $label.obj
		else
			cat verts.csv <(cat $OBJ | tail -$n) > $label.obj
		fi
		cloudcompare.CloudCompare -SILENT -NO_TIMESTAMP -C_EXPORT_FMT LAS -O $label.obj -SAMPLE_MESH DENSITY $density >/dev/null 2>/dev/null
    cat ${label}_SAMPLED_POINTS.las | las-to-csv points | csv-shuffle -f=x,y,z -o=x,y,z | csv-paste "-" "value=$id"
    [[ $verbose ]] && echo "Done!" >&2
		id=$(expr $id - 1)
	done |
  if [[ $show ]]
  then
    tee >(view-points "-;format=3d,ui;fields=x,y,z,id" --size=20000000 "$pc;binary=$bin;fields=$fields")
  else
    cat
  fi
}

function option-description
{
    cat <<eof
--density=[<quality>]; default=20000; Density of mesh point cloud sampling
--verbose, -v; Output progress to stderr
--show, -s; Display cloud when finished
eof
}

function usage
{
    cat <<eof

$name uses tree and LiDAR definitions to procedurally generate a point cloud
as if the defined sensor had scanned a set of random trees of the given species.
Outputs the finished point cloud to STDOUT.
Also creates a temporary directory to store intermediate files.

usage: $name obj [options]

options:
$( option-description  | sed 's/^/    /g' )

eof
    exit 1

}

if [ "$1" = "-parallel" ]; then
	shift 1
	sample_sensor "$@"
	exit $?
fi


if (( $( comma_options_has --help $@ ) || $( comma_options_has -h $@ ) )) ; then usage ; fi
options=$( option-description | comma-options-to-name-value "$@" ) || error "invalid command line options"
comma_path_value_to_var --prefix="options" <<< "$options"
eval "$( option-description | comma-options-to-name-value "$@" | comma_path_value_mangle )"

(( $( comma_options_has --verbose "$@" ) )) && export readonly verbose=true
(( $( comma_options_has --force "$@" ) )) && export readonly recompute=true

set -e # Kill if anything errors out; we don't want it to run everything on bad datasets

wherewasi=`pwd`
fullfilename=`readlink -f $1`
# export TEMPDIR=`mktemp -d`
export TEMPDIR="temp_thingos"
mkdir $TEMPDIR
cd $TEMPDIR

convert $fullfilename $options_density

cd $wherewasi

rm -rf $TEMPDIR
